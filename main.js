!function(e){var n={};function r(_){if(n[_])return n[_].exports;var a=n[_]={i:_,l:!1,exports:{}};return e[_].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=e,r.c=n,r.d=function(e,n,_){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:_})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var _=Object.create(null);if(r.r(_),Object.defineProperty(_,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)r.d(_,a,function(n){return e[n]}.bind(null,a));return _},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s="./src/main.ts")}({"./src/core/doubly-linked-list.ts":
/*!****************************************!*\
  !*** ./src/core/doubly-linked-list.ts ***!
  \****************************************/
/*! exports provided: DoublyLinkedList */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoublyLinkedList", function() { return DoublyLinkedList; });\n/**\n * Linked list for items of type T\n */\nclass DoublyLinkedList {\n    constructor(values = null) {\n        this.head = undefined;\n        this.tail = undefined;\n        this._size = 0;\n        if (values && values.length) {\n            this.fromArray(values);\n        }\n    }\n    reset() {\n        this.head = undefined;\n        this.tail = undefined;\n        this._size = 0;\n    }\n    size() {\n        return this._size;\n    }\n    fromArray(values) {\n        this.reset();\n        for (let i = 0; i < values.length; i++) {\n            this.add(values[i]);\n        }\n    }\n    /**\n     * Adds an item in O(1)\n     **/\n    add(value) {\n        this._size++;\n        const node = {\n            value,\n            next: undefined,\n            prev: undefined,\n        };\n        if (!this.head) {\n            this.head = node;\n        }\n        if (this.tail) {\n            this.tail.next = node;\n            node.prev = this.tail;\n        }\n        this.tail = node;\n    }\n    /**\n     * FIFO removal in O(1)\n     */\n    dequeue() {\n        if (this.head) {\n            const value = this.head.value;\n            this.head = this.head.next;\n            if (!this.head) {\n                this.tail = undefined;\n            }\n            else {\n                this.head.prev = undefined;\n            }\n            this._size--;\n            return value;\n        }\n    }\n    /**\n     * LIFO removal in O(1)\n     */\n    pop() {\n        if (this.tail) {\n            const value = this.tail.value;\n            this.tail = this.tail.prev;\n            if (!this.tail) {\n                this.head = undefined;\n            }\n            else {\n                this.tail.next = undefined;\n            }\n            this._size--;\n            return value;\n        }\n    }\n    /**\n     * Returns an iterator over the values\n     */\n    *values() {\n        let current = this.head;\n        while (current) {\n            yield current.value;\n            current = current.next;\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/core/doubly-linked-list.ts?')},"./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _skipbo_automata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./skipbo/automata */ "./src/skipbo/automata.ts");\n/* harmony import */ var _skipbo_game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./skipbo/game */ "./src/skipbo/game.ts");\n/* harmony import */ var _skipbo_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./skipbo/logger */ "./src/skipbo/logger.ts");\n/* harmony import */ var _skipbo_test_testdeck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./skipbo/test/testdeck */ "./src/skipbo/test/testdeck.ts");\n\n\n\n\n_skipbo_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].enable();\n// use a prepared testdeck and disable shuffle so we can always get the same result\n// useful during development. Fill always finish in round #73 with Player 1 winning.\nfunction createPredictableGame() {\n    const game = new _skipbo_game__WEBPACK_IMPORTED_MODULE_1__["Game"](Object(_skipbo_test_testdeck__WEBPACK_IMPORTED_MODULE_3__["getFullTestDeck"])());\n    game.deck.noShuffle();\n    return game;\n}\n// fully random game, will create the correct Skip Bo Deck internally\nfunction createGame() {\n    const game = new _skipbo_game__WEBPACK_IMPORTED_MODULE_1__["Game"]();\n    game.deck.shuffle();\n    return game;\n}\n// create failing game, running out of cards\n// to reproduce: use the default set and disable shuffle\nfunction createFailingGame() {\n    const game = new _skipbo_game__WEBPACK_IMPORTED_MODULE_1__["Game"](Object(_skipbo_test_testdeck__WEBPACK_IMPORTED_MODULE_3__["getFailingDeck"])());\n    game.deck.noShuffle();\n    return game;\n}\n// let game = createPredictableGame();\nlet game = createGame();\n//create two players\nconst player1 = game.createPlayer("Player 1");\nconst player2 = game.createPlayer("Player 2");\nconst player3 = game.createPlayer("Player 3");\nconst player4 = game.createPlayer("Player 4");\n// Our automata will let the two players\n// play very naively against each other â€” always choosing the first possible \n// card to build or discard. Such a game really wouldn\'t be fun ðŸ˜„ \n// This is great during development and works somehow as our integration test. \nconst automata = new _skipbo_automata__WEBPACK_IMPORTED_MODULE_0__["Automata"](game);\n// let\'s provide our testdeck to get \n// automata.setDeck(getFullTestDeck());\nautomata.run();\n\n\n//# sourceURL=webpack:///./src/main.ts?')},"./src/skipbo/automata.ts":
/*!********************************!*\
  !*** ./src/skipbo/automata.ts ***!
  \********************************/
/*! exports provided: Automata */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Automata", function() { return Automata; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/skipbo/logger.ts");\n\nclass Automata {\n    constructor(game) {\n        this.game = game;\n        this._gameOver = false;\n        this._partialRunCounter = 0;\n    }\n    tryStockCard() {\n        const player = this.currentPlayer;\n        const canPlaceStockCard = this.game.buildingGroup.canPlace(player.currentStockCard);\n        let cardPlaced = null;\n        if (canPlaceStockCard) {\n            cardPlaced = player.drawStockCard();\n            this.game.buildingGroup.autoPlace(cardPlaced);\n        }\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(`Can we place the stock card? `, canPlaceStockCard ? `YES (${cardPlaced})` : \'NO\');\n        return canPlaceStockCard;\n    }\n    tryHandCard() {\n        const player = this.currentPlayer;\n        const handCardsPlayable = this.game.buildingGroup.getBuildingCards(player.getHandCards());\n        const canPlaceHandCard = handCardsPlayable.length > 0;\n        let cardPlaced = null;\n        if (canPlaceHandCard) {\n            // naive approach: just play the first hand card\n            cardPlaced = player.drawHandCard(handCardsPlayable[0]);\n            this.game.buildingGroup.autoPlace(cardPlaced);\n        }\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(`Can we place a hand card? `, canPlaceHandCard ? `YES (${cardPlaced})` : \'NO\');\n        return canPlaceHandCard;\n    }\n    tryDiscardPile() {\n        const player = this.currentPlayer;\n        const cards = player.discardGroup.getTopCards();\n        const firstPlaceableCard = cards.find(card => this.game.buildingGroup.canPlace(card));\n        const canPlaceCard = firstPlaceableCard !== undefined;\n        let cardPlaced = null;\n        if (player.discardGroup.canDraw(firstPlaceableCard)) {\n            cardPlaced = player.discardGroup.drawCard(firstPlaceableCard);\n            this.game.buildingGroup.autoPlace(cardPlaced);\n        }\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(`Can we place a discard card? `, canPlaceCard ? `YES (${cardPlaced})` : \'NO\');\n        return canPlaceCard;\n    }\n    singleRun() {\n        const player = this.currentPlayer;\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].group(`Run partial turn #${this._partialRunCounter++}`);\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(\'Hand Cards:\', player.getHandCards());\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].group(`Current Stock Card: ${player.currentStockCard} (${player.getStockCards().length} remaining)`);\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(\'Stock Card Count:\', player.getStockCards().length);\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(\'Stock Cards:\', player.getStockCards());\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].groupEnd();\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(\'\');\n        player.discardGroup.print(\'Discard Group\');\n        this.game.buildingGroup.print(\'Building Group\');\n        let cardPlayed = false;\n        cardPlayed = this.tryStockCard();\n        if (!cardPlayed) {\n            cardPlayed = this.tryHandCard();\n        }\n        if (!cardPlayed) {\n            cardPlayed = this.tryDiscardPile();\n        }\n        // this is allowed durign a turn not as an effect of discarding a card\n        if (cardPlayed && player.handIsEmpty()) {\n            _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(\'Refill Hand Cards\');\n            player.fillHand();\n        }\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].groupEnd();\n        this.checkWinner();\n        return cardPlayed;\n    }\n    playTurn() {\n        this._partialRunCounter = 0;\n        const player = this.game.nextPlayer();\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].groupCollapsed(`Playing Turn for ${player} round #${this.game.turnId}`);\n        player.fillHand();\n        while (this.singleRun()) {\n            this.game.cleanup();\n        }\n        //always discard a card to complete the turn\n        const discardedCard = player.discardHandCard();\n        console.info(`Discard Card ${discardedCard}`);\n        console.info(`Turn completed`);\n        _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].groupEnd();\n        this.checkWinner();\n    }\n    get currentPlayer() {\n        return this.game.currentPlayer;\n    }\n    getWinner() {\n        return this.game.getPlayers().find(player => player.complete);\n    }\n    gameCompleted() {\n        return this.getWinner() !== undefined;\n    }\n    checkWinner() {\n        if (this.gameCompleted()) {\n            const winner = this.getWinner();\n            this._gameOver = true;\n            _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].info(`Game Completed, Winner is ${winner.getName()}`);\n        }\n    }\n    run() {\n        this.game.dealStockCards();\n        while (!this._gameOver) {\n            this.playTurn();\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/automata.ts?')},"./src/skipbo/card.ts":
/*!****************************!*\
  !*** ./src/skipbo/card.ts ***!
  \****************************/
/*! exports provided: Card, generateSkipBoCards */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Card", function() { return Card; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateSkipBoCards", function() { return generateSkipBoCards; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils.ts");\n\nconst NORMAL_CARD_COUNT = 12;\nconst SKIPBO_CARD_COUNT = 18;\nvar Card;\n(function (Card) {\n    Card[Card["SkipBo"] = -1] = "SkipBo";\n    Card[Card["Empty"] = 0] = "Empty";\n    Card[Card["One"] = 1] = "One";\n    Card[Card["Two"] = 2] = "Two";\n    Card[Card["Three"] = 3] = "Three";\n    Card[Card["Four"] = 4] = "Four";\n    Card[Card["Five"] = 5] = "Five";\n    Card[Card["Six"] = 6] = "Six";\n    Card[Card["Seven"] = 7] = "Seven";\n    Card[Card["Eight"] = 8] = "Eight";\n    Card[Card["Nine"] = 9] = "Nine";\n    Card[Card["Ten"] = 10] = "Ten";\n    Card[Card["Eleven"] = 11] = "Eleven";\n    Card[Card["Twelve"] = 12] = "Twelve";\n})(Card || (Card = {}));\n// this will create an unsorted, factory fresh deck of Skip Bo\nfunction generateSkipBoCards() {\n    // split enum so we can generate our card values dynamically\n    const { values } = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getEnumValuesAndKeys"])(Card);\n    const deck = [];\n    for (let cardValue of values) {\n        if (cardValue === 0) {\n            continue;\n        }\n        const cards = Array.from(Array(NORMAL_CARD_COUNT), () => parseInt(cardValue));\n        deck.push(...cards);\n    }\n    // add our skipbo cards (there are more than the default faces in the deck)\n    const cards = Array.from(Array(SKIPBO_CARD_COUNT), () => Card.SkipBo);\n    deck.push(...cards);\n    return deck;\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/card.ts?')},"./src/skipbo/deck.ts":
/*!****************************!*\
  !*** ./src/skipbo/deck.ts ***!
  \****************************/
/*! exports provided: Deck */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deck", function() { return Deck; });\n/* harmony import */ var _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/doubly-linked-list */ "./src/core/doubly-linked-list.ts");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils.ts");\n\n\nclass Deck {\n    constructor(cards) {\n        this._cards = new _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__["DoublyLinkedList"]();\n        this._canShuffle = true;\n        this._cards.fromArray(cards);\n    }\n    // just for mocking and being predictable\n    // usually this shouldn\'t be part of the deck implementation \n    noShuffle() {\n        this._canShuffle = false;\n    }\n    drawDeckCards(count) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(count > 0, "Can\'t draw less than one card");\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(count <= this._cards.size(), `Deck not big enough (${this._cards.size()}), can\\\'t draw (${count}) card`);\n        let cards = [];\n        while (cards.length < count) {\n            cards.push(this.drawDeckCard());\n        }\n        return cards;\n    }\n    getDeckCards() {\n        return Array.from(this._cards.values());\n    }\n    addCards(...cards) {\n        // merge with remaining cards of the deck\n        const allCards = cards.concat(...this._cards.values());\n        console.log(\'allCards\', allCards);\n        this._cards.fromArray(allCards);\n    }\n    shuffle() {\n        if (this._canShuffle === false) {\n            return;\n        }\n        const cards = this.getDeckCards();\n        this._cards.fromArray(Object(_utils__WEBPACK_IMPORTED_MODULE_1__["shuffle"])(cards));\n    }\n    canDraw(count) {\n        return count <= this._cards.size();\n    }\n    drawDeckCard() {\n        const card = this._cards.pop();\n        return card;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/deck.ts?')},"./src/skipbo/game.ts":
/*!****************************!*\
  !*** ./src/skipbo/game.ts ***!
  \****************************/
/*! exports provided: STOCK_CARD_COUNT, Game */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STOCK_CARD_COUNT", function() { return STOCK_CARD_COUNT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Game", function() { return Game; });\n/* harmony import */ var _pile_building_pile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pile/building-pile */ "./src/skipbo/pile/building-pile.ts");\n/* harmony import */ var _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/doubly-linked-list */ "./src/core/doubly-linked-list.ts");\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./card */ "./src/skipbo/card.ts");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./player */ "./src/skipbo/player.ts");\n/* harmony import */ var _pile_pile_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pile/pile-group */ "./src/skipbo/pile/pile-group.ts");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logger */ "./src/skipbo/logger.ts");\n/* harmony import */ var _deck__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deck */ "./src/skipbo/deck.ts");\n\n\n\n\n\n\n\nconst STOCK_CARD_COUNT = 30;\n// create and shuffle the initial deck\nclass Game {\n    constructor(cards = null) {\n        // hold all completed building cards\n        this.completedDeck = [];\n        this.buildingGroup = new _pile_pile_group__WEBPACK_IMPORTED_MODULE_4__["PileGroup"]();\n        this._players = new _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_1__["DoublyLinkedList"]();\n        this._turnCounter = 0;\n        this._deck = new _deck__WEBPACK_IMPORTED_MODULE_6__["Deck"](cards || Object(_card__WEBPACK_IMPORTED_MODULE_2__["generateSkipBoCards"])());\n        // this._deck.shuffle();\n        this.buildingGroup.add(new _pile_building_pile__WEBPACK_IMPORTED_MODULE_0__["BuildingPile"]());\n        this.buildingGroup.add(new _pile_building_pile__WEBPACK_IMPORTED_MODULE_0__["BuildingPile"]());\n        this.buildingGroup.add(new _pile_building_pile__WEBPACK_IMPORTED_MODULE_0__["BuildingPile"]());\n        this.buildingGroup.add(new _pile_building_pile__WEBPACK_IMPORTED_MODULE_0__["BuildingPile"]());\n    }\n    get deck() {\n        return this._deck;\n    }\n    getDeckCards() {\n        return this._deck.getDeckCards();\n    }\n    resetDeck() {\n        _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].info(\'Deck is completed, shuffle back in completed cars\', this.completedDeck);\n        // add back cards from the completed deck and shuffle\n        this._deck.addCards(...this.completedDeck);\n        this._deck.shuffle();\n    }\n    canDraw(count) {\n        return this._deck.canDraw(count);\n    }\n    drawDeckCards(count) {\n        return this._deck.drawDeckCards(count);\n    }\n    drawDeckCard() {\n        return this._deck.drawDeckCard();\n        ;\n    }\n    dealStockCards() {\n        const players = Array.from(this._players.values());\n        for (let i = 0; i < STOCK_CARD_COUNT; i++) {\n            players.forEach(player => player.addStockCard(this.drawDeckCard()));\n        }\n        _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].group("Dealing stock cards to players");\n        players.forEach(player => {\n            _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].info(`${player} received ${player.getStockCards().length} stock cards`);\n        });\n        _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].groupEnd();\n    }\n    createPlayer(name) {\n        const player = new _player__WEBPACK_IMPORTED_MODULE_3__["Player"](name, this);\n        this._players.add(player);\n        _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].info(`New Player \'${player}\' Added`, player);\n        return player;\n    }\n    cleanup() {\n        const cards = this.buildingGroup.cleanup();\n        if (cards.length > 0) {\n            _logger__WEBPACK_IMPORTED_MODULE_5__["logger"].info(\'Cleaned up piles\');\n        }\n        this.completedDeck.push(...cards);\n    }\n    get currentPlayer() {\n        return this._currentPlayer.value;\n    }\n    getPlayers() {\n        return Array.from(this._players.values());\n    }\n    nextPlayer() {\n        if (!this._currentPlayer) {\n            this._currentPlayer = this._players.head;\n        }\n        else {\n            if (this._currentPlayer.next) {\n                this._currentPlayer = this._currentPlayer.next;\n            }\n            else {\n                this._currentPlayer = this._players.head;\n            }\n        }\n        this._turnCounter++;\n        return this.currentPlayer;\n    }\n    get turnId() {\n        return this._turnCounter;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/game.ts?')},"./src/skipbo/logger.ts":
/*!******************************!*\
  !*** ./src/skipbo/logger.ts ***!
  \******************************/
/*! exports provided: logger */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return logger; });\nlet enabled = false;\nconst enable = () => {\n    enabled = true;\n};\nconst info = (...messages) => {\n    if (enabled) {\n        console.info(...messages);\n    }\n};\nconst group = (...messages) => {\n    if (enabled) {\n        console.group(...messages);\n    }\n};\nconst groupCollapsed = (...messages) => {\n    if (enabled) {\n        console.groupCollapsed(...messages);\n    }\n};\nconst groupEnd = (...messages) => {\n    if (enabled) {\n        console.groupEnd();\n    }\n};\nconst logger = { enable, info, groupCollapsed, group, groupEnd };\n\n\n//# sourceURL=webpack:///./src/skipbo/logger.ts?')},"./src/skipbo/pile/building-pile.ts":
/*!******************************************!*\
  !*** ./src/skipbo/pile/building-pile.ts ***!
  \******************************************/
/*! exports provided: PileRole, BuildingPile */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PileRole", function() { return PileRole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildingPile", function() { return BuildingPile; });\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../card */ "./src/skipbo/card.ts");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils.ts");\n/* harmony import */ var _pile_abstract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pile-abstract */ "./src/skipbo/pile/pile-abstract.ts");\n\n\n\nvar PileRole;\n(function (PileRole) {\n    PileRole[PileRole["BUILDING"] = 1] = "BUILDING";\n    PileRole[PileRole["DISCARDING"] = 2] = "DISCARDING";\n})(PileRole || (PileRole = {}));\nclass BuildingPile extends _pile_abstract__WEBPACK_IMPORTED_MODULE_2__["AbstractPile"] {\n    constructor() {\n        super(PileRole.BUILDING);\n    }\n    isFull() {\n        if (this.getMode() === PileRole.DISCARDING) {\n            return false;\n        }\n        return this.top === _card__WEBPACK_IMPORTED_MODULE_0__["Card"].Twelve;\n    }\n    canDraw(card) {\n        return false;\n    }\n    canPlace(candidate) {\n        const topCard = this.top;\n        if (candidate === _card__WEBPACK_IMPORTED_MODULE_0__["Card"].SkipBo) {\n            return true;\n        }\n        return (candidate - topCard) === 1;\n    }\n    addCard(card) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.isFull() === false, `You can\'t place card on a full pile`);\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.canPlace(card), `You can\'t place card ${card} on ${this.top}`);\n        super.addCard(card);\n    }\n    drawCard(card) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, `You can\'t remove card from building piles`);\n        return null;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/pile/building-pile.ts?')},"./src/skipbo/pile/discard-pile.ts":
/*!*****************************************!*\
  !*** ./src/skipbo/pile/discard-pile.ts ***!
  \*****************************************/
/*! exports provided: DiscardPile */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscardPile", function() { return DiscardPile; });\n/* harmony import */ var _pile_abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pile-abstract */ "./src/skipbo/pile/pile-abstract.ts");\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../card */ "./src/skipbo/card.ts");\n\n\nclass DiscardPile extends _pile_abstract__WEBPACK_IMPORTED_MODULE_0__["AbstractPile"] {\n    constructor() {\n        super(_pile_abstract__WEBPACK_IMPORTED_MODULE_0__["PileRole"].DISCARDING);\n    }\n    isFull() {\n        if (this.getMode() === _pile_abstract__WEBPACK_IMPORTED_MODULE_0__["PileRole"].DISCARDING) {\n            return false;\n        }\n        return this.top === _card__WEBPACK_IMPORTED_MODULE_1__["Card"].Twelve;\n    }\n    canDraw(card) {\n        return this.top === card;\n    }\n    canPlace(candidate) {\n        // We can always place a card on discarding\n        return true;\n    }\n    clear() {\n        throw new Error("You can\'t clear a discar pile");\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/pile/discard-pile.ts?')},"./src/skipbo/pile/pile-abstract.ts":
/*!******************************************!*\
  !*** ./src/skipbo/pile/pile-abstract.ts ***!
  \******************************************/
/*! exports provided: PileRole, AbstractPile */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PileRole", function() { return PileRole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractPile", function() { return AbstractPile; });\n/* harmony import */ var _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/doubly-linked-list */ "./src/core/doubly-linked-list.ts");\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../card */ "./src/skipbo/card.ts");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/utils.ts");\n\n\n\nvar PileRole;\n(function (PileRole) {\n    PileRole[PileRole["BUILDING"] = 1] = "BUILDING";\n    PileRole[PileRole["DISCARDING"] = 2] = "DISCARDING";\n})(PileRole || (PileRole = {}));\nclass AbstractPile {\n    constructor(mode) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(mode, "You need to specify the mode of this pile");\n        this._mode = mode;\n        this._cardList = new _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__["DoublyLinkedList"]([]);\n    }\n    drawCard(card) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.canDraw(card), `Can\'t draw card ${card}`);\n        return this._cardList.pop();\n    }\n    getMode() {\n        return this._mode;\n    }\n    add(...cards) {\n        while (cards.length) {\n            this.addCard(cards.shift());\n        }\n    }\n    addCard(card) {\n        if (card === _card__WEBPACK_IMPORTED_MODULE_1__["Card"].SkipBo) {\n            // Never add SkipBo cards, replace with value it reflects (current card + 1)\n            // this makes it much easier to handle the pile\n            let mimicCard = this.top + 1;\n            this._cardList.add(mimicCard);\n        }\n        else {\n            this._cardList.add(card);\n        }\n    }\n    getCards() {\n        return Array.from(this._cardList.values());\n    }\n    /**\n     * Read the top card value\n     */\n    get top() {\n        if (this._cardList.size() === 0) {\n            return _card__WEBPACK_IMPORTED_MODULE_1__["Card"].Empty;\n        }\n        const card = this._cardList.tail.value;\n        return this._cardList.tail.value;\n    }\n    get size() {\n        return this._cardList.size();\n    }\n    clear() {\n        const cards = this.getCards();\n        this._cardList.reset();\n        return cards;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/pile/pile-abstract.ts?')},"./src/skipbo/pile/pile-group.ts":
/*!***************************************!*\
  !*** ./src/skipbo/pile/pile-group.ts ***!
  \***************************************/
/*! exports provided: PLACE_STRATEGY, PileGroup */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLACE_STRATEGY", function() { return PLACE_STRATEGY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PileGroup", function() { return PileGroup; });\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../card */ "./src/skipbo/card.ts");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils.ts");\n\n\nvar PLACE_STRATEGY;\n(function (PLACE_STRATEGY) {\n    PLACE_STRATEGY[PLACE_STRATEGY["FIRST"] = 0] = "FIRST";\n    PLACE_STRATEGY[PLACE_STRATEGY["EVENLY"] = 1] = "EVENLY";\n})(PLACE_STRATEGY || (PLACE_STRATEGY = {}));\nfunction smallestPile(list) {\n    const sortedList = list.sort((a, b) => a.size - b.size);\n    return sortedList[0];\n}\nfunction getTargetPile(candidates, strategy) {\n    // naive, always take the first pile. We could also randomly choose or use the smallest pile first.\n    switch (strategy) {\n        case PLACE_STRATEGY.EVENLY:\n            return smallestPile(candidates);\n            break;\n        case PLACE_STRATEGY.FIRST:\n            return candidates[0];\n            break;\n    }\n    throw new Error(`Given place strategy (${strategy}) is unknown`);\n}\nclass PileGroup {\n    constructor(placeStrategy = PLACE_STRATEGY.EVENLY) {\n        this._piles = [];\n        this._placeStrategy = placeStrategy;\n    }\n    add(pile) {\n        this._piles.push(pile);\n    }\n    getPileCandidates(card) {\n        const candidates = this._piles.filter((pile) => pile.canPlace(card));\n        return candidates;\n    }\n    canPlace(card) {\n        return this.getPileCandidates(card).length > 0;\n    }\n    getBuildingCards(cards) {\n        const candidateCards = cards.filter(card => this.canPlace(card));\n        return candidateCards;\n    }\n    autoPlace(card) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.canPlace(card), "Can\'t auto-place a card not matching building order");\n        const candidates = this.getPileCandidates(card);\n        let chosenPile = getTargetPile(candidates, this._placeStrategy);\n        chosenPile.addCard(card);\n        return chosenPile;\n    }\n    autoPlaceCards(...cards) {\n        while (cards.length) {\n            this.autoPlace(cards.shift());\n        }\n    }\n    display() {\n        let allCards = this._piles.map(pile => {\n            return pile.getCards();\n        });\n        // calculate heighest stack \n        const maxStackSize = allCards.reduce((maxStackSize, item) => Math.max(maxStackSize, item.length), 0);\n        const transpose = m => Array.from(Array(maxStackSize)).map((x, i) => m.map(x => {\n            return (x[i] === undefined) ? \'â–‘\' : x[i];\n        }));\n        let transposed = transpose(allCards);\n        transposed = transposed.map(item => item.join(\'|\'));\n        return transposed.join(\'\\n\');\n    }\n    print(name) {\n        console.group(name);\n        console.info(this.display());\n        console.groupEnd();\n    }\n    cleanup() {\n        // remove all completed building piles\n        let cards = [];\n        this._piles.forEach(pile => {\n            if (pile.isFull()) {\n                cards.push(...pile.clear());\n            }\n        });\n        return cards;\n    }\n    getDrawCandidates(card) {\n        const candidates = this._piles.filter((pile) => pile.canDraw(card));\n        return candidates;\n    }\n    canDraw(card) {\n        return this.getDrawCandidates(card).length > 0;\n    }\n    drawCard(card) {\n        const candidates = this.getDrawCandidates(card);\n        return candidates[0].drawCard(card);\n    }\n    getTopCards() {\n        return this._piles\n            .map(pile => pile.top)\n            .filter((card) => card !== _card__WEBPACK_IMPORTED_MODULE_0__["Card"].Empty);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/pile/pile-group.ts?')},"./src/skipbo/player.ts":
/*!******************************!*\
  !*** ./src/skipbo/player.ts ***!
  \******************************/
/*! exports provided: HAND_CARD_COUNT, Player */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAND_CARD_COUNT", function() { return HAND_CARD_COUNT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return Player; });\n/* harmony import */ var _pile_discard_pile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pile/discard-pile */ "./src/skipbo/pile/discard-pile.ts");\n/* harmony import */ var _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/doubly-linked-list */ "./src/core/doubly-linked-list.ts");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/utils.ts");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger */ "./src/skipbo/logger.ts");\n/* harmony import */ var _pile_pile_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pile/pile-group */ "./src/skipbo/pile/pile-group.ts");\n\n\n\n\n\nconst HAND_CARD_COUNT = 5;\nclass Player {\n    constructor(_name, _game) {\n        this._name = _name;\n        this._game = _game;\n        this.stockPile = new _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_1__["DoublyLinkedList"]();\n        this.discardGroup = new _pile_pile_group__WEBPACK_IMPORTED_MODULE_4__["PileGroup"]();\n        this.discardGroup.add(new _pile_discard_pile__WEBPACK_IMPORTED_MODULE_0__["DiscardPile"]());\n        this.discardGroup.add(new _pile_discard_pile__WEBPACK_IMPORTED_MODULE_0__["DiscardPile"]());\n        this.discardGroup.add(new _pile_discard_pile__WEBPACK_IMPORTED_MODULE_0__["DiscardPile"]());\n        this.discardGroup.add(new _pile_discard_pile__WEBPACK_IMPORTED_MODULE_0__["DiscardPile"]());\n        this.reset();\n    }\n    getGame() {\n        return this._game;\n    }\n    toString() {\n        return this.getName();\n    }\n    addStockCard(...cards) {\n        while (cards.length) {\n            this.stockPile.add(cards.shift());\n        }\n    }\n    drawStockCard() {\n        _logger__WEBPACK_IMPORTED_MODULE_3__["logger"].info(\'Drawing Stock Card\');\n        return this.stockPile.pop();\n    }\n    get currentStockCard() {\n        if (this.stockPile.size() === 0) {\n            return null;\n        }\n        return this.stockPile.tail.value;\n    }\n    getName() {\n        return this._name;\n    }\n    handIsEmpty() {\n        return this.hand.length === 0;\n    }\n    fillHand() {\n        const delta = HAND_CARD_COUNT - this.hand.length;\n        _logger__WEBPACK_IMPORTED_MODULE_3__["logger"].info(`Drawing ${delta} cards`);\n        if (!this._game.canDraw(delta)) {\n            // shuffle completed decks back in\n            this._game.resetDeck();\n        }\n        const cards = this._game.drawDeckCards(delta);\n        this.hand.push(...cards);\n    }\n    drawHandCard(card) {\n        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.hand.indexOf(card) !== -1, `Card ${card} is not your hand.`);\n        const index = this.hand.indexOf(card);\n        this.hand.splice(index, 1);\n        return card;\n    }\n    getStockCards() {\n        return Array.from(this.stockPile.values());\n    }\n    getHandCards() {\n        return [].concat(this.hand);\n    }\n    reset() {\n        this.stockPile = new _core_doubly_linked_list__WEBPACK_IMPORTED_MODULE_1__["DoublyLinkedList"]();\n        this.hand = [];\n    }\n    discardHandCard() {\n        // draw first hand card\n        const card = this.drawHandCard(this.hand[0]);\n        this.discardGroup.autoPlace(card);\n        return card;\n    }\n    get complete() {\n        return this.stockPile.size() === 0;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/player.ts?')},"./src/skipbo/test/testdeck.ts":
/*!*************************************!*\
  !*** ./src/skipbo/test/testdeck.ts ***!
  \*************************************/
/*! exports provided: getStockCardsPlayer1, getStockCardsPlayer2, getRemainingDeck, testdeckLegacy, getFailingDeck, getFullTestDeck */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStockCardsPlayer1", function() { return getStockCardsPlayer1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStockCardsPlayer2", function() { return getStockCardsPlayer2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRemainingDeck", function() { return getRemainingDeck; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testdeckLegacy", function() { return testdeckLegacy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFailingDeck", function() { return getFailingDeck; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFullTestDeck", function() { return getFullTestDeck; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ "./src/utils.ts");\n/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../card */ "./src/skipbo/card.ts");\n\n\n// Create a deck we know so we can test it properly\nconst remainingDeck = [6, 11, 4, 12, 1, 3, 10, 6, -1, 7, 5, 2, 11, 2, 10, 12, 5, 12, 8, -1, -1, 5, 5, 8, 11, 11, 6, 5, 11, 8, -1, 9, 3, 3, 9, 3, 7, 2, 2, 8, 4, 2, -1, 12, -1, 10, 7, 4, 9, 1, 6, 7, 6, 7, 4, 12, 6, 10, 6, 9, 4, 10, 1, 10, 2, -1, 1, 7, 6, 3, -1, 5, 9, 6, 12, 11, 12, 2, 1, 1, 4, 5, 11, 4, 10, 4, 3, 4, 8, 8, 5, -1, 7, 8, 1, 2, 7, 6, 11, 8, 9, 1];\nconst stockCardsPlayer1 = [5, -1, 10, -1, 6, 3, 9, 2, 7, 3, 12, 11, 2, 8, 5, 11, 3, 2, 9, -1, 1, 10, 5, 2, -1, 3, 1, 1, 5, -1];\nconst stockCardsPlayer2 = [10, 10, 12, 3, 1, -1, 9, 4, 9, 4, 7, 4, 8, 11, 12, 12, -1, 10, 12, 7, 7, 8, 8, 9, 6, 3, -1, 11, -1, 9];\nfunction getStockCardsPlayer1() {\n    return stockCardsPlayer1;\n}\nfunction getStockCardsPlayer2() {\n    return stockCardsPlayer2;\n}\nfunction getRemainingDeck() {\n    return remainingDeck;\n}\nconst testdeckLegacy = [\n    6, 11, 4, 12, 1, 3, 10, 6, -1, 7, 5, 2, 11, 2, 10, 12, 5, 12, 8, -1, -1, 5, 5, 8, 11, 11, 6, 5, 11, 8, -1, 9, 3, 3, 9, 3, 7, 2, 2, 8, 4, 2, -1, 12, -1, 10, 7, 4, 9, 1, 6, 7, 6, 7, 4, 12, 6, 10, 6, 9, 4, 10, 1, 10, 2, -1, 1, 7, 6, 3, -1, 5, 9, 6, 12, 11, 12, 2, 1, 1, 4, 5, 11, 4, 10, 4, 3, 4, 8, 8, 5, -1, 7, 8, 1, 2, 7, 6, 11, 8, 9, 1, 9, -1, -1, 5, 11, 1, -1, 1, 3, 3, 6, -1, 9, 2, 8, 5, 8, 10, 7, 1, 7, -1, 12, 9, 10, 2, -1, 3, 12, 11, 12, 5, 11, 8, 8, 2, 4, 11, 7, 12, 4, 3, 9, 7, 4, 2, 9, 9, -1, 3, 1, 6, 3, -1, 12, 10, 10, -1, 10, 5\n];\nfunction getFailingDeck() {\n    // if you use the default set unshuffled you will run out of cards\n    return Object(_card__WEBPACK_IMPORTED_MODULE_1__["generateSkipBoCards"])();\n}\nfunction getFullTestDeck() {\n    // return testdeckLegacy\n    const stockCards = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["interleaveArrays"])(stockCardsPlayer1, stockCardsPlayer2).reverse();\n    return [\n        ...remainingDeck,\n        ...stockCards\n    ];\n}\n\n\n//# sourceURL=webpack:///./src/skipbo/test/testdeck.ts?')},"./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: interleaveArrays, getEnumValuesAndKeys, shuffle, assert */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interleaveArrays", function() { return interleaveArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnumValuesAndKeys", function() { return getEnumValuesAndKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });\nfunction interleaveArrays(a, b) {\n    assert(a.length === b.length, "Can only interleave arrays with same length");\n    let result = [];\n    for (let i = 0; i < a.length; i++) {\n        result.push(a[i], b[i]);\n    }\n    return result;\n}\n// Extract Keys and Values from a TS enum\nfunction getEnumValuesAndKeys(ENUM) {\n    const keys = Object.keys(ENUM)\n        .filter(k => typeof ENUM[k] === "number")\n        .filter(k => ENUM[k] !== ENUM.SkipBo);\n    const values = keys.map(k => ENUM[k]);\n    return { keys, values };\n}\n// yates shuffle\nfunction shuffle(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        message = message || "Assertion failed";\n        if (typeof Error !== "undefined") {\n            throw new Error(message);\n        }\n        throw message; // Fallback\n    }\n}\n\n\n//# sourceURL=webpack:///./src/utils.ts?')}});